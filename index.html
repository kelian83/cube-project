<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Severance VR Experience - Acte 1</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
      body { margin: 0; overflow: hidden; }
      .a-enter-vr-button { 
        background-color: #1a1a1a !important; 
        border: 2px solid #00ff00 !important;
      }
      #ui-overlay {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-family: monospace;
        font-size: 18px;
        background: rgba(0,0,0,0.7);
        padding: 15px 30px;
        border-radius: 5px;
        z-index: 9999;
        pointer-events: none;
        transition: opacity 0.5s;
      }
      #progress-bar {
        width: 200px;
        height: 8px;
        background: #333;
        border-radius: 4px;
        margin-top: 10px;
        overflow: hidden;
      }
      #progress-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #ff0000, #00ff00);
        transition: width 0.3s ease;
      }
    </style>
  </head>
  <body>
    <div id="ui-overlay">
      <div>CABLES: <span id="cable-count">0</span>/4</div>
      <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <script>
      window.SEVERANCE = {
        connectedCables: 0,
        totalCables: 4,
        isDiscoMode: false,
        ceilingLights: [],
        rgbLights: [],
        speakers: [],
        // Syst√®me Audio Stems
        audioStems: {},
        audioInitialized: false,
        cableToStem: {
          0: 'stem-bass',
          1: 'stem-melody',
          2: 'stem-perc',
          3: 'stem-atmos'
        }
      };

      // Initialisation du syst√®me audio synchronis√©
      function initAudioSystem() {
        if (window.SEVERANCE.audioInitialized) return;
        
        const stemIds = ['stem-bass', 'stem-melody', 'stem-perc', 'stem-atmos'];
        let allLoaded = true;
        
        stemIds.forEach(id => {
          const audio = document.getElementById(id);
          if (audio) {
            audio.volume = 0; // Commence muet
            audio.loop = true;
            window.SEVERANCE.audioStems[id] = audio;
          } else {
            allLoaded = false;
            console.warn('Audio non trouv√©:', id);
          }
        });
        
        if (allLoaded) {
          window.SEVERANCE.audioInitialized = true;
          console.log('‚úì Syst√®me audio initialis√© - Stems pr√™ts');
        }
      }

      // D√©marrer toutes les pistes synchronis√©es (volume 0)
      function startAllStems() {
        if (!window.SEVERANCE.audioInitialized) {
          initAudioSystem();
        }
        
        const stems = window.SEVERANCE.audioStems;
        const startTime = Date.now();
        
        Object.values(stems).forEach(audio => {
          audio.currentTime = 0;
          audio.play().catch(e => console.warn('Autoplay bloqu√©:', e));
        });
        
        console.log('‚ô´ Stems d√©marr√©s (synchronis√©s) - Volume: 0');
      }

      // Activer un stem avec fade in
      function activateStem(cableId) {
        const stemId = window.SEVERANCE.cableToStem[cableId];
        const audio = window.SEVERANCE.audioStems[stemId];
        
        if (!audio) {
          console.warn('Stem non trouv√© pour cable:', cableId);
          return;
        }
        
        // Fade in fluide sur 800ms
        const fadeDuration = 800;
        const fadeSteps = 20;
        const stepTime = fadeDuration / fadeSteps;
        const volumeStep = 1 / fadeSteps;
        let currentStep = 0;
        
        const fadeInterval = setInterval(() => {
          currentStep++;
          audio.volume = Math.min(1, currentStep * volumeStep);
          
          if (currentStep >= fadeSteps) {
            clearInterval(fadeInterval);
            audio.volume = 1;
            console.log('‚ô´ Stem activ√©:', stemId);
          }
        }, stepTime);
      }

      // Mise √† jour de l'√©cran Macintosh
      function updateMacScreen() {
        const progress = (window.SEVERANCE.connectedCables / window.SEVERANCE.totalCables) * 100;
        const macText = document.getElementById('mac-status');
        
        if (!macText) return;
        
        if (progress < 100) {
          macText.setAttribute('value', 
            `DATA CORRUPTION:\n${progress < 50 ? 'CRITICAL' : 'MODERATE'}\n\nREFINEMENT: ${progress}%`);
        } else {
          macText.setAttribute('value', 'QUOTA MET.\n\nREWARD\nAVAILABLE.');
          // Animation clignotante
          macText.setAttribute('animation', {
            property: 'material.opacity',
            from: 1,
            to: 0.3,
            dur: 500,
            dir: 'alternate',
            loop: true,
            easing: 'easeInOutSine'
          });
        }
      }

      function updateUI() {
        document.getElementById("cable-count").textContent = window.SEVERANCE.connectedCables;
        document.getElementById("progress-fill").style.width = 
          (window.SEVERANCE.connectedCables / window.SEVERANCE.totalCables * 100) + "%";
        
        // Mise √† jour de l'√©cran Macintosh
        updateMacScreen();
      }

      function triggerRewardSequence() {
        if (window.SEVERANCE.isDiscoMode) return;
        window.SEVERANCE.isDiscoMode = true;
        console.log("üèÜ QUOTA MET - SEQUENCE INITIATED");
        
        document.getElementById("ui-overlay").style.opacity = "0";
        
        // √âtape 1: Coupure br√®ve du son
        const stems = window.SEVERANCE.audioStems;
        Object.values(stems).forEach(audio => {
          audio.volume = 0;
        });
        
        // √âtape 2: √âteindre les lumi√®res du plafond
        window.SEVERANCE.ceilingLights.forEach((light, i) => {
          setTimeout(() => {
            light.setAttribute("animation", {
              property: "light.intensity",
              to: 0.2,
              dur: 1200,
              easing: "easeOutQuad"
            });
          }, i * 100);
        });
        
        // √âtape 3: Jouer la voix de r√©compense
        setTimeout(() => {
          const voiceReward = document.getElementById('voice-reward');
          if (voiceReward) {
            voiceReward.volume = 1;
            voiceReward.play().catch(e => console.warn('Voice reward:', e));
            console.log('üéôÔ∏è "The Board acknowledges..."');
          }
        }, 500);

        // √âtape 4: Son hydraulique + Descente de la table + Mont√©e des c√¢bles
        setTimeout(() => {
          console.log('‚öôÔ∏è Table descending & Cables rising...');
          
          // Jouer le son hydraulique
          const hydraulicSound = document.getElementById('hydraulic-sound');
          if (hydraulicSound) {
            hydraulicSound.volume = 0.8;
            hydraulicSound.play().catch(e => console.warn('Hydraulic sound:', e));
          }
          
          // Animer la descente du bureau (tous les enfants suivent automatiquement)
          const desk = document.getElementById('severance-desk');
          if (desk) {
            desk.setAttribute('animation', {
              property: 'position',
              to: '0 -2.8 0',
              dur: 3000,
              easing: 'easeInOutQuad'
            });
          }
          
          // Animer la mont√©e des c√¢bles vers le plafond
          const cableSystem = document.getElementById('cable-ceiling-system');
          if (cableSystem) {
            cableSystem.setAttribute('animation', {
              property: 'position',
              to: '0 3.5 0',
              dur: 3000,
              easing: 'easeInOutQuad'
            });
          }
        }, 1500);

        // √âtape 5: Faire monter le bouton OVERTIME
        setTimeout(() => {
          console.log('üî¥ Overtime button rising...');
          const overtimeGroup = document.getElementById('overtime-button-group');
          if (overtimeGroup) {
            overtimeGroup.setAttribute('animation', {
              property: 'position',
              to: '0 0 0',
              dur: 2500,
              easing: 'easeOutBack'
            });
          }
        }, 2500);

        // √âtape 6: Ambiance tendue - lumi√®res rouges
        setTimeout(() => {
          document.querySelector("a-scene").setAttribute("fog", "type: exponential; color: #1a0505; density: 0.025");
          
          // Lumi√®res d'alerte rouges pulsantes
          window.SEVERANCE.rgbLights.forEach((light, index) => {
            light.setAttribute("visible", "true");
            const lightEl = light.querySelector('a-light');
            if (lightEl) {
              lightEl.removeAttribute('rgb-disco');
              lightEl.setAttribute('light', {
                type: 'spot',
                color: '#ff0000',
                intensity: 0.8,
                angle: 40
              });
              lightEl.setAttribute('animation', {
                property: 'light.intensity',
                from: 0.3,
                to: 1.2,
                dur: 800 + (index * 100),
                dir: 'alternate',
                loop: true,
                easing: 'easeInOutSine'
              });
            }
          });
        }, 4500);

        // √âtape 7: Musique en sourdine - tension
        setTimeout(() => {
          const atmos = window.SEVERANCE.audioStems['stem-atmos'];
          if (atmos) {
            let vol = 0;
            const fadeIn = setInterval(() => {
              vol += 0.02;
              atmos.volume = Math.min(0.4, vol);
              if (vol >= 0.4) clearInterval(fadeIn);
            }, 50);
          }
          console.log('üéµ Ambient tension...');
        }, 5000);
      }

      // ========== TRANSITION GLITCH VERS OUTIE WORLD ==========
      function triggerOvertimeTransition() {
        console.log('‚ö° OVERTIME TRANSITION TRIGGERED');
        
        // Jouer le son d'entr√©e ascenseur (piano note)
        const elevatorEntry = document.getElementById('elevator-entry');
        if (elevatorEntry) {
          elevatorEntry.volume = 0.8;
          elevatorEntry.play().catch(e => console.warn('Elevator entry:', e));
        }
        
        // Jouer l'alarme glitch
        const glitchAlarm = document.getElementById('glitch-alarm');
        if (glitchAlarm) {
          glitchAlarm.volume = 1;
          glitchAlarm.play().catch(e => console.warn('Glitch alarm:', e));
        }
        
        // Couper toute la musique
        const stems = window.SEVERANCE.audioStems;
        Object.values(stems).forEach(audio => {
          audio.volume = 0;
          audio.pause();
        });
        
        // R√©cup√©rer le plan glitch (attach√© √† la cam√©ra)
        const glitchPlane = document.getElementById('glitch-plane');
        const camera = document.querySelector('[camera]');
        
        if (glitchPlane) {
          // Rendre le plan visible
          glitchPlane.setAttribute('visible', 'true');
          
          // Effet strobe noir/blanc
          let strobeCount = 0;
          const strobeInterval = setInterval(() => {
            const opacity = strobeCount % 2 === 0 ? 1 : 0;
            const color = strobeCount % 4 < 2 ? '#000000' : '#ffffff';
            glitchPlane.setAttribute('material', `shader: flat; color: ${color}; opacity: ${opacity}; transparent: true; side: double`);
            strobeCount++;
            
            if (strobeCount > 15) {
              clearInterval(strobeInterval);
              // Noir complet avant la transition
              glitchPlane.setAttribute('material', 'shader: flat; color: #000000; opacity: 1; transparent: true; side: double');
              
              // Effectuer le switch apr√®s le blackout
              setTimeout(() => {
                performWorldSwitch();
              }, 400);
            }
          }, 70);
          
          // Effet Camera Shake
          if (camera) {
            cameraShake(camera, 1000);
          }
        } else {
          // Fallback si pas de plan
          performWorldSwitch();
        }
      }
      
      // ========== CAMERA SHAKE EFFECT ==========
      function cameraShake(camera, duration) {
        const originalPos = camera.getAttribute('position');
        const startTime = Date.now();
        const intensity = 0.02;
        
        function shake() {
          const elapsed = Date.now() - startTime;
          if (elapsed > duration) {
            // Restaurer la position originale
            camera.setAttribute('position', originalPos);
            return;
          }
          
          // Diminuer l'intensit√© vers la fin
          const progress = elapsed / duration;
          const currentIntensity = intensity * (1 - progress);
          
          // Position al√©atoire
          const shakeX = (Math.random() - 0.5) * currentIntensity;
          const shakeY = originalPos.y + (Math.random() - 0.5) * currentIntensity;
          const shakeZ = (Math.random() - 0.5) * currentIntensity;
          
          camera.object3D.position.x = originalPos.x + shakeX;
          camera.object3D.position.y = shakeY;
          camera.object3D.position.z = originalPos.z + shakeZ;
          
          requestAnimationFrame(shake);
        }
        
        shake();
      }

      function performWorldSwitch() {
        console.log('üåç Switching to OUTIE WORLD');
        
        const innieWorld = document.getElementById('innie-world');
        const outieWorld = document.getElementById('outie-world');
        const overtimeButton = document.getElementById('overtime-button-group');
        const glitchPlane = document.getElementById('glitch-plane');
        
        // Cacher le monde Innie
        if (innieWorld) {
          innieWorld.setAttribute('visible', 'false');
        }
        
        // Cacher le bouton overtime
        if (overtimeButton) {
          overtimeButton.setAttribute('visible', 'false');
        }
        
        // Afficher le monde Outie
        if (outieWorld) {
          outieWorld.setAttribute('visible', 'true');
        }
        
        // Jouer le son de sortie ascenseur (piano note)
        const elevatorExit = document.getElementById('elevator-exit');
        if (elevatorExit) {
          elevatorExit.volume = 0.8;
          elevatorExit.play().catch(e => console.warn('Elevator exit:', e));
        }
        
        // Changer le ciel
        const sky = document.querySelector('a-sky');
        if (sky) {
          sky.setAttribute('color', '#87CEEB'); // Ciel bleu
        }
        
        // Retirer le brouillard oppressant
        document.querySelector("a-scene").setAttribute("fog", "type: exponential; color: #87CEEB; density: 0.005");
        
        // Fade out du plan noir
        if (glitchPlane) {
          let opacity = 1;
          const fadeOut = setInterval(() => {
            opacity -= 0.05;
            if (opacity <= 0) {
              clearInterval(fadeOut);
              glitchPlane.setAttribute('visible', 'false');
              glitchPlane.setAttribute('material', 'opacity: 0');
            } else {
              glitchPlane.setAttribute('material', `shader: flat; color: #000000; opacity: ${opacity}; transparent: true; side: double`);
            }
          }, 50);
        }
        
        console.log('‚úÖ Welcome to the outside world.');
      }

      // ========== COMPOSANT OVERTIME TRIGGER (Proximity Check) ==========
      AFRAME.registerComponent('overtime-trigger', {
        init: function() {
          this.isPressed = false;
          this.canPress = false;
          this.buttonWorldPos = new THREE.Vector3();
          this.handPos = new THREE.Vector3();
          this.originalY = 0.85; // Position Y originale du bouton
          this.pressedY = 0.78;  // Position Y quand press√©
          
          // R√©cup√©rer les r√©f√©rences des mains
          this.leftHand = null;
          this.rightHand = null;
          
          var self = this;
          this.el.sceneEl.addEventListener('loaded', function() {
            self.leftHand = document.getElementById('leftHand');
            self.rightHand = document.getElementById('rightHand');
            console.log('üî¥ Overtime button: hands referenced');
          });
          
          // Le bouton devient actif apr√®s que l'animation de mont√©e soit termin√©e
          setTimeout(() => {
            this.canPress = true;
            console.log('üî¥ Overtime button READY for proximity detection');
          }, 6000);
          
          //A SUPPRIMER ENTRE [CODE TEST PC - Click avec souris]
          // Event listener pour test PC (click avec souris)
          this.el.addEventListener('click', function() {
            if (self.canPress && !self.isPressed) {
              console.log('üñ±Ô∏è OVERTIME BUTTON clicked (PC test mode)');
              self.onPress(null);
            }
          });
          //A SUPPRIMER SORTIE
        },
        tick: function() {
          if (!this.canPress || this.isPressed) return;
          
          // R√©cup√©rer la position mondiale du bouton
          this.el.object3D.getWorldPosition(this.buttonWorldPos);
          
          // V√©rifier la proximit√© avec chaque main
          var hands = [this.leftHand, this.rightHand];
          var self = this;
          
          hands.forEach(function(hand) {
            if (!hand || self.isPressed) return;
            
            hand.object3D.getWorldPosition(self.handPos);
            var distance = self.buttonWorldPos.distanceTo(self.handPos);
            
            // Si la main est √† moins de 8cm du bouton
            if (distance < 0.08) {
              self.onPress(hand);
            }
          });
        },
        onPress: function(hand) {
          if (this.isPressed) return;
          this.isPressed = true;
          
          console.log('‚ö° OVERTIME BUTTON PRESSED by proximity!');
          
          // Animation d'enfoncement du bouton
          this.el.setAttribute('animation__press', {
            property: 'position',
            to: '0 ' + this.pressedY + ' 0',
            dur: 150,
            easing: 'easeOutQuad'
          });
          
          // Feedback haptique
          this.hapticFeedback(hand);
          
          // D√©clencher la transition apr√®s un court d√©lai
          var self = this;
          setTimeout(function() {
            triggerOvertimeTransition();
          }, 300);
        },
        hapticFeedback: function(hand) {
          if (!hand) return;
          var tc = hand.components["oculus-touch-controls"] || hand.components["tracked-controls"];
          if (tc && tc.controller && tc.controller.gamepad && tc.controller.gamepad.hapticActuators) {
            var ha = tc.controller.gamepad.hapticActuators[0];
            if (ha) {
              try {
                ha.pulse(1, 500);
              } catch (e) {}
            }
          }
        }
      })

      // Alias pour compatibilit√©
      function triggerDiscoMode() {
        triggerRewardSequence();
      }

      AFRAME.registerComponent("rgb-disco", {
        schema: {
          speed: { type: "number", default: 1 },
          colorSet: { type: "string", default: "purple" }
        },
        init: function() {
          this.time = Math.random() * 100;
          this.active = false;
          this.colors = {
            purple: [[148, 0, 211], [75, 0, 130], [238, 130, 238]],
            cyan: [[0, 255, 255], [0, 206, 209], [64, 224, 208]],
            blue: [[0, 0, 255], [30, 144, 255], [65, 105, 225]]
          };
        },
        start: function() { this.active = true; },
        tick: function(time, delta) {
          if (!this.active) return;
          this.time += delta * 0.001 * this.data.speed;
          var colorArr = this.colors[this.data.colorSet] || this.colors.purple;
          var idx = Math.floor(Math.abs(Math.sin(this.time)) * colorArr.length);
          var color = colorArr[idx % colorArr.length];
          var intensity = 0.5 + Math.sin(this.time * 2) * 0.5;
          this.el.setAttribute("light", {
            intensity: intensity * 3,
            color: "rgb(" + color[0] + ", " + color[1] + ", " + color[2] + ")"
          });
        }
      });

      // Composant Luxe Pulse - Style Jazz Club
      AFRAME.registerComponent("luxe-pulse", {
        schema: {
          colorIndex: { type: "int", default: 0 },
          speed: { type: "number", default: 0.4 }
        },
        init: function() {
          this.time = Math.random() * 10;
          // Palette Jazz Club Luxe: Or, Pourpre Profond, Blanc Chaud
          this.luxeColors = [
            { r: 255, g: 215, b: 0 },    // Or (#FFD700)
            { r: 75, g: 0, b: 130 },      // Pourpre Profond (#4B0082)
            { r: 255, g: 244, b: 230 }    // Blanc Chaud (#FFF4E6)
          ];
        },
        tick: function(time, delta) {
          this.time += delta * 0.001 * this.data.speed;
          
          var color = this.luxeColors[this.data.colorIndex % this.luxeColors.length];
          
          // Pulsation douce et √©l√©gante
          var intensity = 1.2 + Math.sin(this.time * Math.PI) * 0.6;
          
          this.el.setAttribute("light", {
            intensity: intensity,
            color: "rgb(" + color.r + ", " + color.g + ", " + color.b + ")"
          });
        }
      });

      AFRAME.registerComponent("speaker-vibrate", {
        schema: {
          active: { type: "boolean", default: false },
          intensity: { type: "number", default: 0.02 },
          frequency: { type: "number", default: 8 }
        },
        init: function() {
          this.basePos = null;
        },
        tick: function(time) {
          if (!this.data.active) return;
          if (!this.basePos) {
            var p = this.el.getAttribute("position");
            this.basePos = {x: p.x, y: p.y, z: p.z};
          }
          var i = this.data.intensity;
          var f = this.data.frequency;
          var vx = Math.sin(time * 0.001 * f * Math.PI) * i;
          var vz = Math.cos(time * 0.001 * f * 1.3 * Math.PI) * i * 0.5;
          this.el.object3D.position.x = this.basePos.x + vx;
          this.el.object3D.position.z = this.basePos.z + vz;
        }
      });

      AFRAME.registerComponent("hanging-cable", {
        schema: {
          cableId: { type: "int", default: 0 },
          anchorX: { type: "number", default: 0 },
          anchorZ: { type: "number", default: 0 },
          length: { type: "number", default: 1.5 }
        },
        init: function() {
          this.isConnected = false;
          this.isGrabbed = false;
          this.grabbedBy = null;
          this.segments = [];
          this.positions = [];
          this.velocities = [];
          this.tipEntity = null;
          this.sparksEntity = null;
          
          var anchorY = 2.95;
          var count = 10;
          
          // ‚úÖ Cr√©er une courbe naturelle de c√¢ble pendu (catenary)
          for (var i = 0; i < count; i++) {
            var t = i / (count - 1); // Normalise 0 √† 1
            var y = anchorY - (t * this.data.length);
            
            // Ajouter un "sag" (affaissement) naturel en forme de parabole
            var sag = Math.sin(t * Math.PI) * 0.15; // Affaissement max 15cm au milieu
            
            // L√©g√®re oscillation al√©atoire pour un effet naturel
            var randomX = (Math.random() - 0.5) * 0.02;
            var randomZ = (Math.random() - 0.5) * 0.02;
            
            this.positions.push(new THREE.Vector3(
              this.data.anchorX + randomX,
              y - sag,
              this.data.anchorZ + randomZ
            ));
            
            this.velocities.push(new THREE.Vector3(0, 0, 0));
          }
          
          this.createVisuals();
        },
        createVisuals: function() {
          var self = this;
          for (var i = 0; i < this.positions.length; i++) {
            var seg = document.createElement("a-cylinder");
            seg.setAttribute("radius", "0.02");
            seg.setAttribute("height", "0.15");
            seg.setAttribute("color", "#1a1a1a");
            seg.setAttribute("material", "roughness: 0.7; metalness: 0.1");
            seg.classList.add("grabbable");
            this.el.appendChild(seg);
            this.segments.push(seg);
          }
          
          this.tipEntity = document.createElement("a-entity");
          this.tipEntity.classList.add("grabbable", "cable-tip");
          
          var jackBody = document.createElement("a-cylinder");
          jackBody.setAttribute("radius", "0.025");
          jackBody.setAttribute("height", "0.1");
          jackBody.setAttribute("color", "#c0c0c0");
          jackBody.setAttribute("material", "roughness: 0.15; metalness: 0.95");
          this.tipEntity.appendChild(jackBody);
          
          var jackTip = document.createElement("a-cone");
          jackTip.setAttribute("radius-bottom", "0.02");
          jackTip.setAttribute("radius-top", "0.008");
          jackTip.setAttribute("height", "0.04");
          jackTip.setAttribute("color", "#e8e8e8");
          jackTip.setAttribute("material", "roughness: 0.1; metalness: 0.98");
          jackTip.setAttribute("position", "0 -0.07 0");
          this.tipEntity.appendChild(jackTip);
          
          this.sparksEntity = document.createElement("a-entity");
          this.sparksEntity.setAttribute("position", "0 -0.1 0");
          
          // D√©sactiver sparks en VR (trop co√ªteux)
          var isVR = this.el.sceneEl.is('vr-mode');
          if (!isVR) {
            for (var j = 0; j < 6; j++) {
              var spark = document.createElement("a-sphere");
              spark.setAttribute("radius", "0.012");
              spark.setAttribute("color", "#00ff44");
              spark.setAttribute("material", "shader: flat; emissive: #00ff44; emissiveIntensity: 2; transparent: true; opacity: 0.8");
              spark.classList.add("spark");
              this.sparksEntity.appendChild(spark);
            }
          } else {
            this.sparksEntity.object3D.visible = false;
          }
          
          this.tipEntity.appendChild(this.sparksEntity);
          this.el.appendChild(this.tipEntity);
        },
        tick: function(time, delta) {
          if (this.isConnected) return;
          
          // Throttle physics √† 30 FPS au lieu de 72
          this.physicsTick = (this.physicsTick || 0) + delta;
          if (this.physicsTick >= 33) {
            var dt = Math.min(this.physicsTick / 1000, 0.033);
            this.simulatePhysics(dt);
            this.updateVisuals();
            this.physicsTick = 0;
          }
          
          // Sparks √† 15 FPS (si actifs)
          if (this.sparksEntity && this.sparksEntity.object3D.visible) {
            this.sparksTick = (this.sparksTick || 0) + delta;
            if (this.sparksTick >= 66) {
              this.animateSparks(time);
              this.sparksTick = 0;
            }
          }
        },
        animateSparks: function(time) {
          if (!this.sparksEntity || !this.sparksEntity.object3D.visible) return;
          var sparks = this.sparksEntity.querySelectorAll(".spark");
          sparks.forEach(function(spark, i) {
            var t = time * 0.004 + i * 1.05;
            var r = 0.03 + Math.sin(t) * 0.02;
            var angle = t * 2;
            
            // ‚úÖ Direct object3D update (80% plus rapide)
            spark.object3D.position.set(
              Math.cos(angle) * r,
              Math.sin(t * 3) * 0.025,
              Math.sin(angle) * r
            );
            
            // ‚úÖ Material opacity direct
            var opacity = 0.4 + Math.sin(t * 4) * 0.4;
            if (spark.object3D.children[0] && spark.object3D.children[0].material) {
              spark.object3D.children[0].material.opacity = opacity;
            }
          });
        },
        simulatePhysics: function(dt) {
          var gravity = -6;
          var damping = 0.88;
          var anchorY = 2.95;
          
          this.positions[0].set(this.data.anchorX, anchorY, this.data.anchorZ);
          this.velocities[0].set(0, 0, 0);
          
          // Vectors temporaires r√©utilisables (√©vite allocations)
          this._tempVec1 = this._tempVec1 || new THREE.Vector3();
          this._tempVec2 = this._tempVec2 || new THREE.Vector3();
          
          if (this.isGrabbed && this.grabbedBy) {
            this.grabbedBy.object3D.getWorldPosition(this._tempVec1);
            var lastIdx = this.positions.length - 1;
            this.positions[lastIdx].lerp(this._tempVec1, 0.4);
          }
          
          for (var i = 1; i < this.positions.length; i++) {
            this.velocities[i].y += gravity * dt;
            
            // ‚úÖ √âvite clone()
            this._tempVec2.copy(this.velocities[i]).multiplyScalar(dt);
            this.positions[i].add(this._tempVec2);
            
            var prev = this.positions[i - 1];
            var curr = this.positions[i];
            var segLen = this.data.length / this.positions.length;
            
            // ‚úÖ √âvite clone()
            this._tempVec1.subVectors(curr, prev);
            var dist = this._tempVec1.length();
            
            if (dist > segLen) {
              this._tempVec1.normalize().multiplyScalar((dist - segLen) * 0.5);
              curr.sub(this._tempVec1);
            }
            this.velocities[i].multiplyScalar(damping);
          }
        },
        updateVisuals: function() {
          var self = this;
          this._dirVec = this._dirVec || new THREE.Vector3();
          this._upVec = this._upVec || new THREE.Vector3(0, 1, 0);
          this._quat = this._quat || new THREE.Quaternion();
          
          this.segments.forEach(function(seg, i) {
            var pos = self.positions[i];
            seg.object3D.position.set(pos.x, pos.y, pos.z);
            if (i < self.positions.length - 1) {
              var next = self.positions[i + 1];
              
              // ‚úÖ √âvite clone()
              self._dirVec.subVectors(next, pos).normalize();
              self._quat.setFromUnitVectors(self._upVec, self._dirVec);
              seg.object3D.quaternion.copy(self._quat);
            }
          });
          var lastPos = this.positions[this.positions.length - 1];
          this.tipEntity.object3D.position.set(lastPos.x, lastPos.y - 0.08, lastPos.z);
        },
        grab: function(hand) {
          if (this.isConnected) return;
          this.isGrabbed = true;
          this.grabbedBy = hand;
          this.hapticPulse(hand, 0.3, 50);
        },
        release: function() {
          this.isGrabbed = false;
          this.grabbedBy = null;
        },
        getTipPosition: function() {
          var lastPos = this.positions[this.positions.length - 1];
          return new THREE.Vector3(lastPos.x, lastPos.y - 0.08, lastPos.z);
        },
        connect: function(portWorldPos) {
          this.isConnected = true;
          this.isGrabbed = false;
          this.grabbedBy = null;
          var lastIdx = this.positions.length - 1;
          this.positions[lastIdx].set(portWorldPos.x, portWorldPos.y + 0.08, portWorldPos.z);
          this.tipEntity.object3D.position.set(portWorldPos.x, portWorldPos.y, portWorldPos.z);
          this.sparksEntity.setAttribute("visible", "false");
          
          // Activer le stem audio correspondant
          activateStem(this.data.cableId);
          
          window.SEVERANCE.connectedCables++;
          updateUI();
          console.log("Cable " + (this.data.cableId + 1) + " connected! ‚Üí Stem activ√©");
          var leftHand = document.getElementById("leftHand");
          var rightHand = document.getElementById("rightHand");
          this.hapticPulse(leftHand, 1, 200);
          this.hapticPulse(rightHand, 1, 200);
          if (window.SEVERANCE.connectedCables >= window.SEVERANCE.totalCables) {
            setTimeout(triggerRewardSequence, 500);
          }
        },
        hapticPulse: function(hand, intensity, duration) {
          if (!hand) return;
          
          // ‚úÖ Support Quest 3 (oculus-touch-controls)
          var tc = hand.components["oculus-touch-controls"] || hand.components["tracked-controls"];
          if (tc && tc.controller && tc.controller.gamepad && tc.controller.gamepad.hapticActuators) {
            var ha = tc.controller.gamepad.hapticActuators[0];
            if (ha) {
              try {
                ha.pulse(intensity, duration);
              } catch (e) {
                console.warn("Haptic pulse failed:", e);
              }
            }
          }
        }
      });

      AFRAME.registerComponent("bo-console", {
        schema: { ports: { type: "int", default: 4 } },
        init: function() {
          this.portPositions = [];
          this.portStates = [];
          this.portRings = [];
          this.cableComponents = [];  // ‚úÖ Cache
          this.createConsole();
          this.createPorts();
          
          // ‚úÖ Cache les c√¢bles √† l'init
          var self = this;
          setTimeout(function() {
            var cables = document.querySelectorAll("[hanging-cable]");
            cables.forEach(function(cableEl) {
              if (cableEl.components["hanging-cable"]) {
                self.cableComponents.push(cableEl.components["hanging-cable"]);
              }
            });
            console.log("Cached", self.cableComponents.length, "cables");
          }, 100);
        },
        createConsole: function() {
          var body = document.createElement("a-box");
          body.setAttribute("width", "0.6");
          body.setAttribute("height", "0.12");
          body.setAttribute("depth", "0.3");
          body.setAttribute("color", "#b8b8b8");
          body.setAttribute("material", "roughness: 0.25; metalness: 0.9");
          body.setAttribute("position", "0 0.06 0");
          this.el.appendChild(body);
          
          var front = document.createElement("a-box");
          front.setAttribute("width", "0.58");
          front.setAttribute("height", "0.1");
          front.setAttribute("depth", "0.02");
          front.setAttribute("color", "#1a1a1a");
          front.setAttribute("material", "roughness: 0.4; metalness: 0.2");
          front.setAttribute("position", "0 0.06 0.15");
          this.el.appendChild(front);
          
          var logo = document.createElement("a-text");
          logo.setAttribute("value", "B&O");
          logo.setAttribute("color", "#c0c0c0");
          logo.setAttribute("width", "0.8");
          logo.setAttribute("align", "center");
          logo.setAttribute("position", "0 0.1 0.162");
          this.el.appendChild(logo);
        },
        createPorts: function() {
          var spacing = 0.12;
          var startX = -spacing * 1.5;
          var y = 0.04;
          var z = 0.16;
          for (var i = 0; i < this.data.ports; i++) {
            var x = startX + i * spacing;
            var port = document.createElement("a-cylinder");
            port.setAttribute("radius", "0.022");
            port.setAttribute("height", "0.03");
            port.setAttribute("color", "#050505");
            port.setAttribute("rotation", "90 0 0");
            port.setAttribute("position", x + " " + y + " " + z);
            this.el.appendChild(port);
            
            var ring = document.createElement("a-torus");
            ring.setAttribute("radius", "0.032");
            ring.setAttribute("radius-tubular", "0.006");
            ring.setAttribute("color", "#ff0000");
            ring.setAttribute("material", "shader: flat; emissive: #ff0000; emissiveIntensity: 1.5");
            ring.setAttribute("rotation", "90 0 0");
            ring.setAttribute("position", x + " " + y + " " + (z + 0.01));
            this.el.appendChild(ring);
            
            this.portPositions.push(new THREE.Vector3(x, y, z));
            this.portStates.push(false);
            this.portRings.push(ring);
          }
        },
        tick: function() {
          // ‚úÖ Utilise le cache au lieu de querySelectorAll
          if (!this.cableComponents.length) return;
          
          this._consolePos = this._consolePos || new THREE.Vector3();
          this._portWorld = this._portWorld || new THREE.Vector3();
          
          this.el.object3D.getWorldPosition(this._consolePos);
          var self = this;
          
          this.cableComponents.forEach(function(comp) {
            if (!comp || comp.isConnected) return;
            var tipPos = comp.getTipPosition();
            
            for (var i = 0; i < self.portPositions.length; i++) {
              if (self.portStates[i]) continue;
              
              // ‚úÖ √âvite clone()
              self._portWorld.copy(self.portPositions[i]).add(self._consolePos);
              
              // ‚úÖ distanceToSquared (10x plus rapide)
              var distSq = tipPos.distanceToSquared(self._portWorld);
              if (distSq < 0.01) {  // 0.1¬≤ = 0.01
                self.portStates[i] = true;
                var ring = self.portRings[i];
                ring.setAttribute("color", "#00ff00");
                ring.setAttribute("material", "shader: flat; emissive: #00ff00; emissiveIntensity: 2");
                comp.connect(self._portWorld);
                break;
              }
            }
          });
        }
      });

      AFRAME.registerComponent("cable-grabber", {
        init: function() {
          this.grabbedCable = null;
          this.cableComponents = [];  // ‚úÖ Cache
          
          this.el.addEventListener("gripdown", this.onGrab.bind(this));
          this.el.addEventListener("gripup", this.onRelease.bind(this));
          this.el.addEventListener("triggerdown", this.onGrab.bind(this));
          this.el.addEventListener("triggerup", this.onRelease.bind(this));
          this.el.addEventListener("squeezed", this.onGrab.bind(this));
          this.el.addEventListener("squeezeend", this.onRelease.bind(this));
          
          // ‚úÖ Cache les c√¢bles
          var self = this;
          setTimeout(function() {
            var cables = document.querySelectorAll("[hanging-cable]");
            cables.forEach(function(cableEl) {
              if (cableEl.components["hanging-cable"]) {
                self.cableComponents.push(cableEl.components["hanging-cable"]);
              }
            });
          }, 100);
          
          this.el.addEventListener("controllerconnected", (evt) => {
            console.log("Controller connected:", evt.detail.name);
          });
        },
        onGrab: function() {
          if (this.grabbedCable) return;
          
          // ‚úÖ Utilise le cache
          if (!this.cableComponents.length) return;
          
          this._handPos = this._handPos || new THREE.Vector3();
          this.el.object3D.getWorldPosition(this._handPos);
          
          var closest = null;
          var closestDistSq = 0.16; // 0.4¬≤ = 0.16 (40cm)
          var self = this;
          
          this.cableComponents.forEach(function(comp) {
            if (!comp || comp.isConnected || comp.isGrabbed) return;
            
            // ‚úÖ distanceToSquared (10x plus rapide)
            var tipDistSq = self._handPos.distanceToSquared(comp.getTipPosition());
            if (tipDistSq < closestDistSq) {
              closestDistSq = tipDistSq;
              closest = comp;
            }
          });
          
          if (closest) {
            closest.grab(this.el);
            this.grabbedCable = closest;
            console.log("Cable grabbed by", this.el.id, "at distance:", Math.sqrt(closestDistSq).toFixed(3));
          }
        },
        onRelease: function() {
          if (this.grabbedCable) {
            this.grabbedCable.release();
            this.grabbedCable = null;
          }
        }
      });

      document.addEventListener("DOMContentLoaded", function() {
        console.log("Severance VR - Ready");
        
        // D√©tection WebXR
        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
            if (supported) {
              console.log("‚úì WebXR immersive-vr support√©");
            } else {
              console.warn("‚ö† WebXR immersive-vr NON support√©");
            }
          });
        } else {
          console.warn("‚ö† navigator.xr non disponible");
        }
      });
      
      // ‚úÖ Composant pour grab avec souris (PC)
      AFRAME.registerComponent("desktop-grabber", {
        init: function() {
          this.grabbedCable = null;
          this.cableComponents = [];
          this.isMouseDown = false;
          this.raycaster = new THREE.Raycaster();
          this.mouse = new THREE.Vector2();
          
          var self = this;
          
          // Cache les c√¢bles
          setTimeout(function() {
            var cables = document.querySelectorAll("[hanging-cable]");
            cables.forEach(function(cableEl) {
              if (cableEl.components["hanging-cable"]) {
                self.cableComponents.push(cableEl.components["hanging-cable"]);
              }
            });
            console.log("Desktop grabber: cached", self.cableComponents.length, "cables");
          }, 200);
          
          // Events souris
          document.addEventListener("mousedown", this.onMouseDown.bind(this));
          document.addEventListener("mouseup", this.onMouseUp.bind(this));
          document.addEventListener("mousemove", this.onMouseMove.bind(this));
          
          // Events tactiles
          document.addEventListener("touchstart", this.onTouchStart.bind(this));
          document.addEventListener("touchend", this.onTouchEnd.bind(this));
          document.addEventListener("touchmove", this.onTouchMove.bind(this));
        },
        onMouseDown: function(evt) {
          this.isMouseDown = true;
          this.tryGrab(evt.clientX, evt.clientY);
        },
        onMouseUp: function() {
          this.isMouseDown = false;
          if (this.grabbedCable) {
            this.grabbedCable.release();
            this.grabbedCable = null;
          }
        },
        onMouseMove: function(evt) {
          if (!this.isMouseDown || !this.grabbedCable) return;
          this.updateGrabPosition(evt.clientX, evt.clientY);
        },
        onTouchStart: function(evt) {
          if (evt.touches.length > 0) {
            this.isMouseDown = true;
            this.tryGrab(evt.touches[0].clientX, evt.touches[0].clientY);
          }
        },
        onTouchEnd: function() {
          this.isMouseDown = false;
          if (this.grabbedCable) {
            this.grabbedCable.release();
            this.grabbedCable = null;
          }
        },
        onTouchMove: function(evt) {
          if (!this.isMouseDown || !this.grabbedCable || evt.touches.length === 0) return;
          this.updateGrabPosition(evt.touches[0].clientX, evt.touches[0].clientY);
        },
        tryGrab: function(clientX, clientY) {
          var camera = this.el.sceneEl.camera;
          var canvas = this.el.sceneEl.canvas;
          
          this.mouse.x = (clientX / canvas.clientWidth) * 2 - 1;
          this.mouse.y = -(clientY / canvas.clientHeight) * 2 + 1;
          
          this.raycaster.setFromCamera(this.mouse, camera);
          
          var closest = null;
          var closestDist = 0.5;
          var self = this;
          
          this.cableComponents.forEach(function(comp) {
            if (!comp || comp.isConnected || comp.isGrabbed) return;
            var tipPos = comp.getTipPosition();
            var dist = self.raycaster.ray.distanceToPoint(tipPos);
            if (dist < closestDist) {
              closestDist = dist;
              closest = comp;
            }
          });
          
          if (closest) {
            // Cr√©er un helper invisible pour le grab
            if (!this.grabHelper) {
              this.grabHelper = document.createElement("a-entity");
              this.grabHelper.setAttribute("id", "grab-helper");
              this.el.sceneEl.appendChild(this.grabHelper);
            }
            closest.grab(this.grabHelper);
            this.grabbedCable = closest;
            console.log("Desktop: Cable grabbed");
          }
        },
        updateGrabPosition: function(clientX, clientY) {
          if (!this.grabHelper) return;
          
          var camera = this.el.sceneEl.camera;
          var canvas = this.el.sceneEl.canvas;
          
          this.mouse.x = (clientX / canvas.clientWidth) * 2 - 1;
          this.mouse.y = -(clientY / canvas.clientHeight) * 2 + 1;
          
          this.raycaster.setFromCamera(this.mouse, camera);
          
          // Calculer la position √† 1.5m devant la cam√©ra
          var dir = this.raycaster.ray.direction.clone();
          var origin = this.raycaster.ray.origin.clone();
          var pos = origin.add(dir.multiplyScalar(1.5));
          
          this.grabHelper.object3D.position.copy(pos);
        }
      });
      
      // ‚úÖ Monitoring des performances VR
      AFRAME.registerComponent("performance-monitor", {
        init: function() {
          this.frameCount = 0;
          this.lastTime = performance.now();
          this.worstFrame = 0;
          this.droppedFrames = 0;
        },
        tick: function(time, delta) {
          this.frameCount++;
          
          // Frame drop detection
          if (delta > 20) {
            this.droppedFrames++;
            console.warn("‚ö† Frame drop:", delta.toFixed(2) + "ms");
          }
          
          if (delta > this.worstFrame) {
            this.worstFrame = delta;
          }
          
          // Log toutes les 5 secondes
          if (time - this.lastTime > 5000) {
            var avgFps = this.frameCount / 5;
            console.log("üìä Perf:", avgFps.toFixed(1), "FPS avg | Worst frame:", this.worstFrame.toFixed(2), "ms | Drops:", this.droppedFrames);
            this.frameCount = 0;
            this.lastTime = time;
            this.worstFrame = 0;
            this.droppedFrames = 0;
          }
        }
      });
    </script>

    <a-scene 
      vr-mode-ui="enabled: true"
      webxr="requiredFeatures: local-floor,hand-tracking; referenceSpaceType: local-floor"
      renderer="antialias: true; colorManagement: true; sortObjects: true; physicallyCorrectLights: true"
      fog="type: exponential; color: #f0f0f0; density: 0.008"
      performance-monitor
      desktop-grabber>
      
      <a-assets timeout="3000">
        <a-asset-item id="speaker-model" src="enceinte_deluxe.glb"></a-asset-item>
        <a-asset-item id="outie-asset" src="outie_world.glb"></a-asset-item>
        
        <!-- Audio Stems pour le Data Refinement -->
        <audio id="stem-bass" src="audio/stem-bass.mp3" preload="auto"></audio>
        <audio id="stem-melody" src="audio/stem-melody.mp3" preload="auto" loop></audio>
        <audio id="stem-perc" src="audio/stem-perc.mp3" preload="auto" loop></audio>
        <audio id="stem-atmos" src="audio/stem-atmos.mp3" preload="auto" loop></audio>
        <audio id="voice-reward" src="audio/voice-reward.mp3" preload="auto"></audio>
        <audio id="hydraulic-sound" src="audio/hydraulic.mp3" preload="auto"></audio>
        <audio id="glitch-alarm" src="audio/glitch-alarm.mp3" preload="auto"></audio>
        <audio id="elevator-entry" src="audio/elevator_entry.mp3" preload="auto"></audio>
        <audio id="elevator-exit" src="audio/elevator_exit.mp3" preload="auto"></audio>
        
        <a-mixin id="wall-panel" material="color: #ffffff; roughness: 0.1; metalness: 0.1"></a-mixin>
        <a-mixin id="floor-carpet" material="color: #5B7C65; roughness: 0.95; metalness: 0"></a-mixin>
        <a-mixin id="aluminum" material="color: #c0c0c0; roughness: 0.2; metalness: 0.9"></a-mixin>
        <a-mixin id="dark-metal" material="color: #2a2a2a; roughness: 0.3; metalness: 0.7"></a-mixin>
      </a-assets>

      <!-- ========== INNIE WORLD ========== -->
      <a-entity id="innie-world">
        <a-plane position="0 0 0" rotation="-90 0 0" width="10" height="8" mixin="floor-carpet"></a-plane>
        <a-plane position="0 3 0" rotation="90 0 0" width="10" height="8" material="color: #e8e8e8; roughness: 0.3"></a-plane>

        <a-entity id="ceiling-lights">
        <a-entity class="ceiling-light-unit" position="-2.5 2.98 -2">
          <a-box class="ceiling-panel" width="1.5" height="0.02" depth="1.2" material="color: #f0f8ff; emissive: #f0f8ff; emissiveIntensity: 0.8"></a-box>
          <a-light type="point" intensity="0.6" distance="4" decay="2" color="#f0f8ff"></a-light>
        </a-entity>
        <a-entity class="ceiling-light-unit" position="0 2.98 -2">
          <a-box class="ceiling-panel" width="1.5" height="0.02" depth="1.2" material="color: #f0f8ff; emissive: #f0f8ff; emissiveIntensity: 0.8"></a-box>
          <a-light type="point" intensity="0.6" distance="4" decay="2" color="#f0f8ff"></a-light>
        </a-entity>
        <a-entity class="ceiling-light-unit" position="2.5 2.98 -2">
          <a-box class="ceiling-panel" width="1.5" height="0.02" depth="1.2" material="color: #f0f8ff; emissive: #f0f8ff; emissiveIntensity: 0.8"></a-box>
          <a-light type="point" intensity="0.6" distance="4" decay="2" color="#f0f8ff"></a-light>
        </a-entity>
        <a-entity class="ceiling-light-unit" position="-2.5 2.98 0">
          <a-box class="ceiling-panel" width="1.5" height="0.02" depth="1.2" material="color: #f0f8ff; emissive: #f0f8ff; emissiveIntensity: 0.8"></a-box>
          <a-light type="point" intensity="0.6" distance="4" decay="2" color="#f0f8ff"></a-light>
        </a-entity>
        <a-entity class="ceiling-light-unit" position="0 2.98 0">
          <a-box class="ceiling-panel" width="1.5" height="0.02" depth="1.2" material="color: #f0f8ff; emissive: #f0f8ff; emissiveIntensity: 0.8"></a-box>
          <a-light type="point" intensity="0.8" distance="5" decay="2" color="#f0f8ff"></a-light>
        </a-entity>
        <a-entity class="ceiling-light-unit" position="2.5 2.98 0">
          <a-box class="ceiling-panel" width="1.5" height="0.02" depth="1.2" material="color: #f0f8ff; emissive: #f0f8ff; emissiveIntensity: 0.8"></a-box>
          <a-light type="point" intensity="0.6" distance="4" decay="2" color="#f0f8ff"></a-light>
        </a-entity>
        <a-entity class="ceiling-light-unit" position="-2.5 2.98 2">
          <a-box class="ceiling-panel" width="1.5" height="0.02" depth="1.2" material="color: #f0f8ff; emissive: #f0f8ff; emissiveIntensity: 0.8"></a-box>
          <a-light type="point" intensity="0.6" distance="4" decay="2" color="#f0f8ff"></a-light>
        </a-entity>
        <a-entity class="ceiling-light-unit" position="0 2.98 2">
          <a-box class="ceiling-panel" width="1.5" height="0.02" depth="1.2" material="color: #f0f8ff; emissive: #f0f8ff; emissiveIntensity: 0.8"></a-box>
          <a-light type="point" intensity="0.6" distance="4" decay="2" color="#f0f8ff"></a-light>
        </a-entity>
        <a-entity class="ceiling-light-unit" position="2.5 2.98 2">
          <a-box class="ceiling-panel" width="1.5" height="0.02" depth="1.2" material="color: #f0f8ff; emissive: #f0f8ff; emissiveIntensity: 0.8"></a-box>
          <a-light type="point" intensity="0.6" distance="4" decay="2" color="#f0f8ff"></a-light>
        </a-entity>
      </a-entity>

      <a-plane position="0 1.5 -4" width="10" height="3" mixin="wall-panel"></a-plane>
      <a-plane position="0 1.5 4" rotation="0 180 0" width="10" height="3" mixin="wall-panel"></a-plane>
      <a-plane position="-5 1.5 0" rotation="0 90 0" width="8" height="3" mixin="wall-panel"></a-plane>
      <a-plane position="5 1.5 0" rotation="0 -90 0" width="8" height="3" mixin="wall-panel"></a-plane>

      <a-entity id="severance-desk" position="0 0 0">
        <!-- Structure du bureau -->
        <a-box position="0 0.75 0" width="2" height="0.05" depth="1" material="color: #e8e8e8; roughness: 0.15; metalness: 0.05"></a-box>
        <a-box position="-0.9 0.375 -0.4" width="0.06" height="0.75" depth="0.06" mixin="aluminum"></a-box>
        <a-box position="0.9 0.375 -0.4" width="0.06" height="0.75" depth="0.06" mixin="aluminum"></a-box>
        <a-box position="-0.9 0.375 0.4" width="0.06" height="0.75" depth="0.06" mixin="aluminum"></a-box>
        <a-box position="0.9 0.375 0.4" width="0.06" height="0.75" depth="0.06" mixin="aluminum"></a-box>
        
        <!-- Macintosh Terminal (enfant du bureau) -->
        <a-entity id="macintosh-terminal" position="-0.65 0.78 0">
          <a-box width="0.25" height="0.28" depth="0.25" material="color: #c9b99a; roughness: 0.7; metalness: 0"></a-box>
          <a-box position="0 0.03 0.11" width="0.18" height="0.14" depth="0.02" material="color: #001100; emissive: #001a00; emissiveIntensity: 0.2"></a-box>
          <a-box position="0 -0.08 0.126" width="0.12" height="0.01" depth="0.01" color="#1a1a1a"></a-box>
          <a-entity id="mac-screen-text" position="0 0.03 0.122">
            <a-text id="mac-status" 
                    value="DATA CORRUPTION:\nCRITICAL\n\nREFINEMENT: 0%" 
                    color="#33ff00" 
                    width="0.35" 
                    align="center"
                    font="monoid"
                    anchor="center"
                    baseline="center"
                    wrap-count="18"></a-text>
          </a-entity>
        </a-entity>

        <!-- Classeurs (enfant du bureau) -->
        <a-entity id="folders" position="0.6 0.78 -0.15">
          <a-box position="0 0.15 0" width="0.08" height="0.3" depth="0.22" material="color: #6a6a6a; roughness: 0.5"></a-box>
          <a-box position="0.1 0.15 0" width="0.08" height="0.3" depth="0.22" material="color: #5a5a5a; roughness: 0.5"></a-box>
          <a-box position="0.2 0.12 0" width="0.08" height="0.24" depth="0.22" material="color: #7a7a7a; roughness: 0.5"></a-box>
        </a-entity>

        <!-- Cadre photo (enfant du bureau) -->
        <a-entity id="photo-frame" position="0.75 0.78 0.25">
          <a-box width="0.12" height="0.15" depth="0.02" material="color: #2a2a2a; roughness: 0.3; metalness: 0.5"></a-box>
          <a-box position="0 0 0.011" width="0.09" height="0.12" depth="0.005" material="color: #d4a574; roughness: 0.9"></a-box>
        </a-entity>

        <!-- Console B&O (enfant du bureau) -->
        <a-entity id="bo-console" position="0 0.78 0.2" bo-console="ports: 4"></a-entity>
      </a-entity>

      <!-- ========== SYST√àME DE C√ÇBLES AU PLAFOND (s√©par√© du bureau) ========== -->
      <a-entity id="cable-ceiling-system" position="0 0 0">
        <!-- Support c√¢bles au plafond -->
        <a-entity position="0 2.95 0.12">
          <a-box width="0.6" height="0.04" depth="0.15" material="color: #2a2a2a; metalness: 0.7"></a-box>
        </a-entity>
        
        <!-- C√¢bles suspendus -->
        <a-entity id="cables-group">
          <a-entity id="cable-1" hanging-cable="cableId: 0; anchorX: -0.2; anchorZ: 0.1; length: 1.5"></a-entity>
          <a-entity id="cable-2" hanging-cable="cableId: 1; anchorX: -0.07; anchorZ: 0.15; length: 1.45"></a-entity>
          <a-entity id="cable-3" hanging-cable="cableId: 2; anchorX: 0.07; anchorZ: 0.15; length: 1.48"></a-entity>
          <a-entity id="cable-4" hanging-cable="cableId: 3; anchorX: 0.2; anchorZ: 0.1; length: 1.52"></a-entity>
        </a-entity>
      </a-entity>

      <a-entity id="speaker-left" position="-4 0 -3" gltf-model="#speaker-model" speaker-vibrate="active: false"></a-entity>

      <a-entity id="speaker-right" position="4 0 -3" gltf-model="#speaker-model" speaker-vibrate="active: false"></a-entity>

      

      <a-entity id="disco-lights">
        <a-entity id="rgb-1" position="-3 2.5 -2" visible="false">
          <a-light type="spot" angle="40" penumbra="0.5" intensity="0" color="#9400d3" rgb-disco="speed: 1.2; colorSet: purple"></a-light>
        </a-entity>
        <a-entity id="rgb-2" position="3 2.5 -2" visible="false">
          <a-light type="spot" angle="40" penumbra="0.5" intensity="0" color="#00ffff" rgb-disco="speed: 0.9; colorSet: cyan"></a-light>
        </a-entity>
        <a-entity id="rgb-3" position="-3 2.5 2" visible="false">
          <a-light type="spot" angle="40" penumbra="0.5" intensity="0" color="#4169e1" rgb-disco="speed: 1.5; colorSet: blue"></a-light>
        </a-entity>
        <a-entity id="rgb-4" position="3 2.5 2" visible="false">
          <a-light type="spot" angle="40" penumbra="0.5" intensity="0" color="#ee82ee" rgb-disco="speed: 0.7; colorSet: purple"></a-light>
        </a-entity>
        <a-entity id="rgb-center" position="0 2.8 0" visible="false">
          <a-light type="point" intensity="0" distance="8" color="#00ffff" rgb-disco="speed: 2; colorSet: cyan"></a-light>
        </a-entity>
      </a-entity>

      <a-light type="ambient" color="#d0d0d0" intensity="0.4"></a-light>
      </a-entity>
      <!-- ========== FIN INNIE WORLD ========== -->

      <!-- ========== OUTIE WORLD (Monde Ext√©rieur) ========== -->
      <a-entity id="outie-world" visible="false" position="0 0 0">
        <a-entity gltf-model="#outie-asset" scale="3 3 3"></a-entity>
        <a-light type="ambient" color="#ffeedd" intensity="0.6"></a-light>
        <a-light type="directional" color="#ffffcc" intensity="0.8" position="5 10 5"></a-light>
      </a-entity>
      <!-- ========== FIN OUTIE WORLD ========== -->

      <!-- ========== OVERTIME BUTTON (Sous le sol initialement) ========== -->
      <a-entity id="overtime-button-group" position="0 -1.5 0">
        <!-- Pi√©destal -->
        <a-cylinder id="button-pedestal" 
                    radius="0.25" 
                    height="0.8" 
                    color="#1a1a1a" 
                    material="roughness: 0.3; metalness: 0.8"
                    position="0 0.4 0">
        </a-cylinder>
        <!-- Bouton rouge interactif -->
        <a-cylinder id="overtime-button" 
                    class="clickable" 
                    radius="0.15" 
                    height="0.08" 
                    color="#cc0000" 
                    material="shader: flat; emissive: #ff0000; emissiveIntensity: 0.5"
                    position="0 0.85 0"
                    overtime-trigger>
          <!-- Anneau lumineux autour du bouton -->
          <a-torus radius="0.18" 
                   radius-tubular="0.015" 
                   color="#ff3333" 
                   material="shader: flat; emissive: #ff0000; emissiveIntensity: 1"
                   rotation="90 0 0"
                   position="0 0 0">
          </a-torus>
        </a-cylinder>
      </a-entity>
      <!-- ========== FIN OVERTIME BUTTON ========== -->

      <a-entity id="rig" position="0 0 2">
        <a-camera position="0 1.6 0" look-controls="pointerLockEnabled: false" wasd-controls="acceleration: 20">
          <a-cursor color="#00ff00" fuse="false" raycaster="objects: .grabbable, .clickable"></a-cursor>
          <!-- Plan Glitch pour effet de transition (devant les yeux) -->
          <a-plane id="glitch-plane" 
                   position="0 0 -0.15" 
                   width="0.5" 
                   height="0.3" 
                   material="shader: flat; color: #000000; opacity: 0; transparent: true; side: double"
                   visible="false">
          </a-plane>
        </a-camera>
        
        <!-- Mains VR (enfants du rig, position 0 0 0) -->
        <a-entity id="leftHand" 
                  position="0 0 0" 
                  hand-controls="hand: left; handModelStyle: lowPoly; color: #ffcccc"
                  raycaster="objects: .grabbable, .clickable; lineColor: #00ffff; far: 0.8; showLine: false" 
                  cable-grabber>
        </a-entity>
        <a-entity id="rightHand" 
                  position="0 0 0" 
                  hand-controls="hand: right; handModelStyle: lowPoly; color: #ffcccc"
                  raycaster="objects: .grabbable, .clickable; lineColor: #ff00ff; far: 0.8; showLine: false" 
                  cable-grabber>
        </a-entity>
      </a-entity>

      <a-sky color="#e0e0e0"></a-sky>
    </a-scene>

    <script>
      document.querySelector("a-scene").addEventListener("loaded", function() {
        document.querySelectorAll(".ceiling-light-unit").forEach(function(el) {
          window.SEVERANCE.ceilingLights.push(el.querySelector("a-light"));
        });
        document.querySelectorAll("#disco-lights > a-entity").forEach(function(el) {
          window.SEVERANCE.rgbLights.push(el);
        });
        window.SEVERANCE.speakers.push(document.getElementById("speaker-left"));
        window.SEVERANCE.speakers.push(document.getElementById("speaker-right"));
        
        // Initialiser le syst√®me audio
        initAudioSystem();
        
        console.log("Scene loaded - refs initialized");
        console.log("üéµ Audio System Ready - Click to start stems");
      });

      // D√©marrer les stems au premier clic (contourne l'autoplay policy)
      document.addEventListener('click', function initStems() {
        startAllStems();
        document.removeEventListener('click', initStems);
      }, { once: true });
      
      // Ou au premier grip VR
      document.addEventListener('gripdown', function initStemsVR() {
        startAllStems();
        document.removeEventListener('gripdown', initStemsVR);
      }, { once: true });
    </script>
  </body>
</html>
